# Conventions
This document defines how _Components_ communicate, behave, and enforce rules
within Brain. For the structural model of _Layers_, _Systems_, and boundaries,
see [Boundaries & Responsibilities](boundaries-and-responsibilities.md).

> Check the [Glossary](glossary.md) for key terms such as _Layer_, _System_, _Resource_,
> _Service_, et cetera.

------------------------------------------------------------------------
## APIs
TL;DR &mdash; `services/*/*/component.py` exports a list of interfaces which are
the canonical surface area for a given _Service_.

Each _Service_ must define a _Public API_. These _Public APIs_:
- Start with Protobuf definitions
- Are the canonical and authoritative (Python) interface to the _Service_
- Are the sole permitted surface for other _Component_ callers
- Define method signatures using envelope-like request/response messages

### Protobufs and gRPC
The Protobuf definitions themselves exist only to autogen the gRPC code. gRPC
exists in this project only as the publication/transport mechanism to support
_Layer_ 2 callers; internal East-West traffic among _Services_ uses the _Public_
(Python) API exclusively.

So, despite being responsible for the start-with-Protobufs design of the
_Services_ Python APIs, the gRPC surface (called the _Brain Core SDK_) is
actually additional layer _on top of_ the _Public API_.

Again - gRPC is not the canonical interface, the _Public APIs_ are. gRPC simply
exists to create the _Brain Core SDK_ which allows _Actors_ access to the
system from across network boundaries.

The _Public API_ and gRPC surface are not required to be one-to-one. A _Service_
may expose _Public API_ methods that are internal-only and therefore not
published on the _Brain Core SDK_.

Protos live in `protos/`, Python is regenerated on build, git-ignored, and lives
in `generated/`, while `services/` holds implementations.

------------------------------------------------------------------------
## Pydantic Contracts
Pydantic is the canonical contract system for configuration and typed data
exchange in Brain.

### Scope
- Use `BaseSettings`/`pydantic-settings` for runtime configuration models.
- Use `BaseModel` for cross-_Service_ and cross-_Layer_ boundary contracts.
- Use `BaseModel` for shared structured error and envelope primitives.

### Required model defaults
- Set `extra="forbid"` unless there is a concrete, documented reason not to.
- Set `frozen=True` unless the model is explicitly stateful and mutable by
  design.

### Validation boundaries
- Validate at ingress boundaries using `model_validate(...)`.
- Treat validated models as authoritative inside domain logic; avoid re-validating
  ad hoc dictionaries throughout call chains.
- Prefer explicit validation failures with stable error messages over silent
  coercion paths.

### Serialization boundaries
- Use `model_dump(mode="python")` for in-process structured handoff where a
  plain mapping is required.
- Keep transport adapters explicit about mapping to/from wire types.

### Contract shape rule
- Do not maintain parallel contract shapes for the same boundary (for example:
  dataclass + dict + Pydantic for one message type). One boundary contract,
  one canonical typed model.

------------------------------------------------------------------------
## Envelopes
All cross-_Layer_ and cross-_Service_ communication must use _Envelopes_. An
_Envelope_ consists of:
- Metadata
- Payload
- Errors

### gRPC API Typing Note
For protobuf/gRPC compile-time type enforcement, _Service_ APIs should generally
use operation-specific request/response messages that are envelope-like
(`metadata`, typed `payload`, and `errors` where applicable), rather than a
single polymorphic wire-envelope type at every RPC boundary.

### Envelope Kinds
**Command Envelope:** Generated by L2 for _Capability_ invocation.
**Event Envelope:** Generated by L1 upon external or system-triggered activity.
**Result Envelope:** Used for responses to other _Enveloped_ messages.
**Stream Envelope:** \[TODO\]/reserved - future real-time streaming support.

### Metadata (Structured)
- `envelope_id`: _required_ ULID
- `trace_id`: _required_ ULID
- `parent_id`: _optional_ ULID
- `timestamp`: _required_ int64
- `kind`: _required_ string (one of `command`, `event`, `result`, `stream`)
- `source`: _required_ string (e.g. `cli`, `agent`, `switchboard`, `job`)
- `principal`: _required_ string (e.g. `operator`, `commitment`, `core`)

_Envelope_ subclasses may append their own metadata. For clarity, `source` is
the immediate emitting _Component_ for _"this" specific Envelope_, whereas
`principal` is the accountable identity (effective authority) for the request.
_Components_ are required to propagate `principal` unchanged across calls.

**Illustrative (non-literal) example:**
The _Operator_ requests a reminder in 1 hour. A message is passed from the
Switchboard to the Agent like:
  - `source = "switchboard"`
  - `principal = "operator"`
which results in a message from the Agent to the Scheduler like:
  - `source = "agent"`
  - `principal = "operator"`

An hour later, the schedule fires and the Job invokes the Agent like:
  - `source = "job"`
  - `principal = "operator"`
which results in a message from the Agent to the Attention Router like:
  - `source = "agent"`
  - `principal = "operator"`

### Tracing
A `trace_id` scopes a single execution episode. In the example above, the first
two _Envelopes_ share the same `trace_id`. The third and fourth share a new
`trace_id` (distinct from the first two), and the third sets `parent_id` to the
`envelope_id` of the scheduling _Envelope_ from the prior _Trace_.

This keeps each execution episode independently observable while preserving
cross-_Trace_ causality for long-term lineage and analysis. This provides for a
DAG of _Envelopes_ across time, with _Trace_ segments as execution partitions.

### Payload
Domain-specific content.

> You can use these oats to make oatmeal, bread, whatever you want. I don't
> care, they're your oats.  
> &mdash; Dwight K. Schrute

### Errors
Most usually Errors will be present in a Result _Envelope_, but are not invalid
in any _Envelope_. Errors are a collection of structured objects representing
some failure mode/state.

------------------------------------------------------------------------
## Principal Identity Model
The _Principal_ is "who the system treats as accountable" for a given request.

**`operator`** - All "personal assistant" work should ultimately roll up to the
_Operator_.

**`<service>`** (e.g. `switchboard`, `ctlc`) - This represents a _Layer_ 1
_Service_ acting autonomously. This is used when _Services_ initiate work
without an immediate upstream request (think scheduled jobs, inbound interrupt,
etc.)

**`core`** - Rare. Only used for truly low-level, cross-cutting "infrastructure"
behavior which are explicitly system-meta in nature.

------------------------------------------------------------------------
## SDKs
### Brain SDK
The _Brain Core SDK_ is the public interface for L2 _Actors_ of Brain Core
using Protobuf/gRPC. All L2 _Actors_ must be built on the _Brain Core SDK_.

The SDK contains no business logic; it simply exists as an access layer across
network boundaries to the public L1 _Service_ APIs.

### Capability SDK
The _Capability SDK_ supports registration and management of _Capabilities_
(_Ops_ and _Skills_) including both logic and metadata such as Policy
declarations.

------------------------------------------------------------------------
## Error Taxonomy
Errors must be categorized as:
- terminal
- retriable

Errors may carry optional category fields such as:
- conflict
- dependency
- not_found
- policy
- validation

Policy violations are, by definition, terminal, and should not be retried.

### Transport vs Domain Failure Mapping
To avoid ambiguity at _Service_ boundaries:
- **Domain failures** (validation, conflict, not_found, policy) are returned as
  typed structured errors in the envelope-like response.
- **Transport/infrastructure failures** (dependency unavailable, internal
  runtime faults) are surfaced as transport failures on gRPC status codes.

This keeps domain behavior explicit and machine-readable while preserving normal
transport semantics for network/runtime outages.

------------------------------------------------------------------------
## Policy Enforcement Rule
All _Capability_ invocations (including within _Skills_) MUST pass through
Capability Engine `invoke()`. _Skills_ must not directly call other _Skills_ or
_Ops_ by importing implementations. Policy Service evaluation is mandatory and
recursive.

### Invocation Lineage and Audit Fields
Capability Engine and Policy Service must persist structured lineage and policy
audit metadata for every invocation (allowed or denied).

Required lineage fields:
- `envelope_id`
- `trace_id`
- `parent_id`
- `invocation_id`
- `parent_invocation_id`
- `source`
- `actor`
- `channel`

Required policy/audit fields:
- `capability_id`
- `capability_version`
- `policy_decision_id`
- `policy_regime_id`
- `allowed` (bool)
- `reason_codes[]`
- `obligations[]`
- `approval proposal token` when approval is required

Nested capability calls must mint a new `envelope_id`, set `parent_id` to the
parent envelope, and route through Capability Engine public invoke API so the
same policy and audit contract is enforced recursively.

### Approval Transport Contracts
Policy Service -> Attention Router approval notifications must be token-only.

Required outbound notification fields:
- `proposal_token`
- `capability_id`
- `capability_version`
- `summary`
- `actor`
- `channel`
- `trace_id`
- `invocation_id`
- `expires_at`

Attention Router -> Policy Service correlation payloads must include actor and
channel plus one of the deterministic correlators:
- `approval_token`
- `reply_to_proposal_token`
- `reaction_to_proposal_token`

`message_text` may be included for immediate next-turn correlation and
disambiguation fallback.

------------------------------------------------------------------------
## Process Assumptions
- L2 _Actors_ are process-and-network isolated
- L1 _Services_ are process-local, but restricted to _Public APIs_
- L0 _Substrates_ and _Adapters_ are non-local

------------------------------------------------------------------------
_End of Conventions_
